<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Algorithmique de graphes: Référence de la classe TP1::Labyrinthe</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Algorithmique de graphes
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Généré par Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Recherche');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_t_p1_1_1_labyrinthe.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Fonctions membres publiques</a> &#124;
<a href="#pri-methods">Fonctions membres privées</a> &#124;
<a href="#pri-attribs">Attributs privés</a> &#124;
<a href="class_t_p1_1_1_labyrinthe-members.html">Liste de tous les membres</a>  </div>
  <div class="headertitle">
<div class="title">Référence de la classe TP1::Labyrinthe</div>  </div>
</div><!--header-->
<div class="contents">

<p>Classe représentant un labyrinthe formé de plusieurs pièces dotées de portes de couleur.  
 <a href="class_t_p1_1_1_labyrinthe.html#details">Plus de détails...</a></p>

<p><code>#include &lt;Labyrinthe.h&gt;</code></p>
<div class="dynheader">
Graphe de collaboration de TP1::Labyrinthe:</div>
<div class="dyncontent">
<div class="center"><img src="class_t_p1_1_1_labyrinthe__coll__graph.png" border="0" usemap="#_t_p1_1_1_labyrinthe_coll__map" alt="Collaboration graph"/></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_p1_1_1_labyrinthe_1_1_noeud_liste_pieces.html">NoeudListePieces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Noeud typique d'une liste chaînée circulaire.  <a href="class_t_p1_1_1_labyrinthe_1_1_noeud_liste_pieces.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Fonctions membres publiques</h2></td></tr>
<tr class="memitem:a81f1cf775efc5f50a6149473c0696624"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_p1_1_1_labyrinthe.html#a81f1cf775efc5f50a6149473c0696624">Labyrinthe</a> ()</td></tr>
<tr class="memdesc:a81f1cf775efc5f50a6149473c0696624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par défaut.  <a href="class_t_p1_1_1_labyrinthe.html#a81f1cf775efc5f50a6149473c0696624">Plus de détails...</a><br /></td></tr>
<tr class="separator:a81f1cf775efc5f50a6149473c0696624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5913959d3fb11e73889c3d8f1fc9f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_p1_1_1_labyrinthe.html#a6e5913959d3fb11e73889c3d8f1fc9f7">Labyrinthe</a> (const <a class="el" href="class_t_p1_1_1_labyrinthe.html">Labyrinthe</a> &amp;source)</td></tr>
<tr class="memdesc:a6e5913959d3fb11e73889c3d8f1fc9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur de copie.  <a href="class_t_p1_1_1_labyrinthe.html#a6e5913959d3fb11e73889c3d8f1fc9f7">Plus de détails...</a><br /></td></tr>
<tr class="separator:a6e5913959d3fb11e73889c3d8f1fc9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a1aafe089fcb0ba65fa65eb0d1811d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_p1_1_1_labyrinthe.html#af9a1aafe089fcb0ba65fa65eb0d1811d">~Labyrinthe</a> ()</td></tr>
<tr class="memdesc:af9a1aafe089fcb0ba65fa65eb0d1811d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructeur.  <a href="class_t_p1_1_1_labyrinthe.html#af9a1aafe089fcb0ba65fa65eb0d1811d">Plus de détails...</a><br /></td></tr>
<tr class="separator:af9a1aafe089fcb0ba65fa65eb0d1811d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0f6278ee9ab2f47a48f7811f9ab095"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_p1_1_1_labyrinthe.html">Labyrinthe</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_p1_1_1_labyrinthe.html#a2a0f6278ee9ab2f47a48f7811f9ab095">operator=</a> (const <a class="el" href="class_t_p1_1_1_labyrinthe.html">Labyrinthe</a> &amp;source)</td></tr>
<tr class="memdesc:a2a0f6278ee9ab2f47a48f7811f9ab095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surcharge de l'opérateur =.  <a href="class_t_p1_1_1_labyrinthe.html#a2a0f6278ee9ab2f47a48f7811f9ab095">Plus de détails...</a><br /></td></tr>
<tr class="separator:a2a0f6278ee9ab2f47a48f7811f9ab095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854dc263c65a447286038fde7843ec41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_p1_1_1_labyrinthe.html#a854dc263c65a447286038fde7843ec41">chargeLabyrinthe</a> (<a class="el" href="namespace_t_p1.html#a8b5ef3e0301394a6503b5b11ab59690e">Couleur</a> couleur, std::ifstream &amp;entree)</td></tr>
<tr class="memdesc:a854dc263c65a447286038fde7843ec41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode fournie dans le fichier <a class="el" href="_labyrinthe_8cpp.html" title="Le code des méthodes membres et privés de la classe Labyrinthe.">Labyrinthe.cpp</a>, elle charge un fichier contenant un labyrinthe d'une certaine couleur.  <a href="class_t_p1_1_1_labyrinthe.html#a854dc263c65a447286038fde7843ec41">Plus de détails...</a><br /></td></tr>
<tr class="separator:a854dc263c65a447286038fde7843ec41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb99d3daf4ea5f84f1d810a84e295579"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_p1_1_1_labyrinthe.html#abb99d3daf4ea5f84f1d810a84e295579">printPieces</a> ()</td></tr>
<tr class="separator:abb99d3daf4ea5f84f1d810a84e295579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720f66e4297666f346bb24a05cc5a973"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_p1_1_1_labyrinthe.html#a720f66e4297666f346bb24a05cc5a973">ajoutePieceLabyrinthe</a> (const <a class="el" href="class_t_p1_1_1_piece.html">Piece</a> &amp;p)</td></tr>
<tr class="memdesc:a720f66e4297666f346bb24a05cc5a973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cette fonction doit ajouter la pièce p à un labyrinthe.  <a href="class_t_p1_1_1_labyrinthe.html#a720f66e4297666f346bb24a05cc5a973">Plus de détails...</a><br /></td></tr>
<tr class="separator:a720f66e4297666f346bb24a05cc5a973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2181692e1946ce3c42242acb34bcbe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_p1_1_1_labyrinthe.html#aaf2181692e1946ce3c42242acb34bcbe">solutionner</a> (<a class="el" href="namespace_t_p1.html#a8b5ef3e0301394a6503b5b11ab59690e">Couleur</a> joueur)</td></tr>
<tr class="memdesc:aaf2181692e1946ce3c42242acb34bcbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cette méthode doit solutionner un labyrinthe pour le joueur spécifié par joueur.  <a href="class_t_p1_1_1_labyrinthe.html#aaf2181692e1946ce3c42242acb34bcbe">Plus de détails...</a><br /></td></tr>
<tr class="separator:aaf2181692e1946ce3c42242acb34bcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c496d235d32655572107f1ea18b8978"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_t_p1.html#a8b5ef3e0301394a6503b5b11ab59690e">Couleur</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_p1_1_1_labyrinthe.html#a0c496d235d32655572107f1ea18b8978">trouveGagnant</a> ()</td></tr>
<tr class="memdesc:a0c496d235d32655572107f1ea18b8978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cette méthode devra appeler quatre fois la méthode <a class="el" href="class_t_p1_1_1_labyrinthe.html#aaf2181692e1946ce3c42242acb34bcbe" title="Cette méthode doit solutionner un labyrinthe pour le joueur spécifié par joueur.">solutionner()</a>, une fois par couleur, pour déterminer quel est le joueur qui peut solutionner le labyrinthe en le moins de déplacements.  <a href="class_t_p1_1_1_labyrinthe.html#a0c496d235d32655572107f1ea18b8978">Plus de détails...</a><br /></td></tr>
<tr class="separator:a0c496d235d32655572107f1ea18b8978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9fc76e432836bbf89547e5489784520"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_p1_1_1_piece.html">Piece</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_p1_1_1_labyrinthe.html#ac9fc76e432836bbf89547e5489784520">getDepart</a> () const</td></tr>
<tr class="memdesc:ac9fc76e432836bbf89547e5489784520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur pour le membre depart.  <a href="class_t_p1_1_1_labyrinthe.html#ac9fc76e432836bbf89547e5489784520">Plus de détails...</a><br /></td></tr>
<tr class="separator:ac9fc76e432836bbf89547e5489784520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2ef4938471d2739e877c7d131b8e3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_p1_1_1_piece.html">Piece</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_p1_1_1_labyrinthe.html#a7e2ef4938471d2739e877c7d131b8e3e">getArrivee</a> () const</td></tr>
<tr class="memdesc:a7e2ef4938471d2739e877c7d131b8e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur pour le membre arrivee.  <a href="class_t_p1_1_1_labyrinthe.html#a7e2ef4938471d2739e877c7d131b8e3e">Plus de détails...</a><br /></td></tr>
<tr class="separator:a7e2ef4938471d2739e877c7d131b8e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14c211f4a87871e33a3477b0be1fd63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_p1_1_1_labyrinthe.html#ae14c211f4a87871e33a3477b0be1fd63">appartient</a> (const <a class="el" href="class_t_p1_1_1_piece.html">Piece</a> &amp;p) const</td></tr>
<tr class="memdesc:ae14c211f4a87871e33a3477b0be1fd63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie si une pièce portant le nom de la pièce fournie se trouve dans le labyrinthe.  <a href="class_t_p1_1_1_labyrinthe.html#ae14c211f4a87871e33a3477b0be1fd63">Plus de détails...</a><br /></td></tr>
<tr class="separator:ae14c211f4a87871e33a3477b0be1fd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Fonctions membres privées</h2></td></tr>
<tr class="memitem:a4b4d2f9b7dc1c3572e720269b9bdad0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_p1_1_1_labyrinthe.html#a4b4d2f9b7dc1c3572e720269b9bdad0b">ajoutePassage</a> (<a class="el" href="namespace_t_p1.html#a8b5ef3e0301394a6503b5b11ab59690e">Couleur</a> couleur, int i1, int j1, int i2, int j2)</td></tr>
<tr class="memdesc:a4b4d2f9b7dc1c3572e720269b9bdad0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode privée fournie dans le fichier <a class="el" href="_labyrinthe_8cpp.html" title="Le code des méthodes membres et privés de la classe Labyrinthe.">Labyrinthe.cpp</a>, elle ajoute un passage dans un labyrinthe.  <a href="class_t_p1_1_1_labyrinthe.html#a4b4d2f9b7dc1c3572e720269b9bdad0b">Plus de détails...</a><br /></td></tr>
<tr class="separator:a4b4d2f9b7dc1c3572e720269b9bdad0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75016674aca0669c9ef0b8c25c8a3b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_p1_1_1_labyrinthe.html#ac75016674aca0669c9ef0b8c25c8a3b7">placeDepart</a> (const std::string &amp;nom)</td></tr>
<tr class="memdesc:ac75016674aca0669c9ef0b8c25c8a3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode privée, elle sert pour charger un labyrinthe.  <a href="class_t_p1_1_1_labyrinthe.html#ac75016674aca0669c9ef0b8c25c8a3b7">Plus de détails...</a><br /></td></tr>
<tr class="separator:ac75016674aca0669c9ef0b8c25c8a3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe6b916bc3ab9ac20dd130220ff1d81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_p1_1_1_labyrinthe.html#adfe6b916bc3ab9ac20dd130220ff1d81">placeArrivee</a> (const std::string &amp;nom)</td></tr>
<tr class="memdesc:adfe6b916bc3ab9ac20dd130220ff1d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Même chose que pour la fonction placeDepart décrite plus haut, mais pour le pointeur arrivee d'un labyrinthe.  <a href="class_t_p1_1_1_labyrinthe.html#adfe6b916bc3ab9ac20dd130220ff1d81">Plus de détails...</a><br /></td></tr>
<tr class="separator:adfe6b916bc3ab9ac20dd130220ff1d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5551ff7dce5becc68b2e6508c9d6d5fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_p1_1_1_labyrinthe_1_1_noeud_liste_pieces.html">NoeudListePieces</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_p1_1_1_labyrinthe.html#a5551ff7dce5becc68b2e6508c9d6d5fb">trouvePiece</a> (const std::string &amp;nom) const</td></tr>
<tr class="memdesc:a5551ff7dce5becc68b2e6508c9d6d5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode privée.  <a href="class_t_p1_1_1_labyrinthe.html#a5551ff7dce5becc68b2e6508c9d6d5fb">Plus de détails...</a><br /></td></tr>
<tr class="separator:a5551ff7dce5becc68b2e6508c9d6d5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Attributs privés</h2></td></tr>
<tr class="memitem:a8eb7ef93bae46710cbbc6b07db3e9184"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_p1_1_1_labyrinthe_1_1_noeud_liste_pieces.html">NoeudListePieces</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_p1_1_1_labyrinthe.html#a8eb7ef93bae46710cbbc6b07db3e9184">dernier</a></td></tr>
<tr class="separator:a8eb7ef93bae46710cbbc6b07db3e9184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c30a4b682aa2846674740f9ae011ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_p1_1_1_piece.html">Piece</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_p1_1_1_labyrinthe.html#a41c30a4b682aa2846674740f9ae011ee">depart</a></td></tr>
<tr class="separator:a41c30a4b682aa2846674740f9ae011ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b79d83a29c1790677c446439092545"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_p1_1_1_piece.html">Piece</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_p1_1_1_labyrinthe.html#a96b79d83a29c1790677c446439092545">arrivee</a></td></tr>
<tr class="separator:a96b79d83a29c1790677c446439092545"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description détaillée</h2>
<div class="textblock"><p>Classe représentant un labyrinthe formé de plusieurs pièces dotées de portes de couleur. </p>
</div><h2 class="groupheader">Documentation des constructeurs et destructeur</h2>
<a id="a81f1cf775efc5f50a6149473c0696624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f1cf775efc5f50a6149473c0696624">&#9670;&nbsp;</a></span>Labyrinthe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TP1::Labyrinthe::Labyrinthe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructeur par défaut. </p>

</div>
</div>
<a id="a6e5913959d3fb11e73889c3d8f1fc9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5913959d3fb11e73889c3d8f1fc9f7">&#9670;&nbsp;</a></span>Labyrinthe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TP1::Labyrinthe::Labyrinthe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_p1_1_1_labyrinthe.html">Labyrinthe</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructeur de copie. </p>

</div>
</div>
<a id="af9a1aafe089fcb0ba65fa65eb0d1811d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a1aafe089fcb0ba65fa65eb0d1811d">&#9670;&nbsp;</a></span>~Labyrinthe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TP1::Labyrinthe::~Labyrinthe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructeur. </p>

</div>
</div>
<h2 class="groupheader">Documentation des fonctions membres</h2>
<a id="a4b4d2f9b7dc1c3572e720269b9bdad0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4d2f9b7dc1c3572e720269b9bdad0b">&#9670;&nbsp;</a></span>ajoutePassage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TP1::Labyrinthe::ajoutePassage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_t_p1.html#a8b5ef3e0301394a6503b5b11ab59690e">Couleur</a>&#160;</td>
          <td class="paramname"><em>couleur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Méthode privée fournie dans le fichier <a class="el" href="_labyrinthe_8cpp.html" title="Le code des méthodes membres et privés de la classe Labyrinthe.">Labyrinthe.cpp</a>, elle ajoute un passage dans un labyrinthe. </p>
<p>Fonction déjà fournie permettant d'ajouter une porte à une pièce.</p>
<p>Elle est appelée par la méthode <a class="el" href="class_t_p1_1_1_labyrinthe.html#a854dc263c65a447286038fde7843ec41" title="Méthode fournie dans le fichier Labyrinthe.cpp, elle charge un fichier contenant un labyrinthe d&#39;une ...">chargeLabyrinthe()</a></p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Couleur</td><td>couleur Couleur de la porte à ajouter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">int</td><td>i1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">int</td><td>j1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">int</td><td>i2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">int</td><td>j2 </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Références <a class="el" href="class_t_p1_1_1_piece.html#ae60deab3477259bdc1902b14677f9726">TP1::Piece::ajoutePorte()</a>, et <a class="el" href="class_t_p1_1_1_labyrinthe_1_1_noeud_liste_pieces.html#a0dfcd04c1cbe96c96568cb4045b1ed4a">TP1::Labyrinthe::NoeudListePieces::piece</a>.</p>
<div class="dynheader">
Voici le graphe d'appel pour cette fonction :</div>
<div class="dyncontent">
<div class="center"><img src="class_t_p1_1_1_labyrinthe_a4b4d2f9b7dc1c3572e720269b9bdad0b_cgraph.png" border="0" usemap="#class_t_p1_1_1_labyrinthe_a4b4d2f9b7dc1c3572e720269b9bdad0b_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a720f66e4297666f346bb24a05cc5a973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a720f66e4297666f346bb24a05cc5a973">&#9670;&nbsp;</a></span>ajoutePieceLabyrinthe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TP1::Labyrinthe::ajoutePieceLabyrinthe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_p1_1_1_piece.html">Piece</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cette fonction doit ajouter la pièce p à un labyrinthe. </p>
<p>Fonction déjà fournie permettant d'ajouter une pièce au labyrinthe (si elle ne s'y trouve pas déjà)</p>
<p>Dans le cas où une pièce du labyrinthe porte déjà un même nom, la méthode ne doit rien faire (faire un simple return, sans générer d'exception).</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>La pièce à ajouter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>La pièce appartient au labyrinthe; </dd></dl>

<p class="reference">Références <a class="el" href="class_t_p1_1_1_labyrinthe_1_1_noeud_liste_pieces.html#a0dfcd04c1cbe96c96568cb4045b1ed4a">TP1::Labyrinthe::NoeudListePieces::piece</a>, et <a class="el" href="class_t_p1_1_1_labyrinthe_1_1_noeud_liste_pieces.html#a2f88570e73a4af6e882edd199bbb34d2">TP1::Labyrinthe::NoeudListePieces::suivant</a>.</p>

</div>
</div>
<a id="ae14c211f4a87871e33a3477b0be1fd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14c211f4a87871e33a3477b0be1fd63">&#9670;&nbsp;</a></span>appartient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TP1::Labyrinthe::appartient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_p1_1_1_piece.html">Piece</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie si une pièce portant le nom de la pièce fournie se trouve dans le labyrinthe. </p>

<p class="reference">Références <a class="el" href="class_t_p1_1_1_piece.html#a54f5bdf6916250a3124dbe70935aa480">TP1::Piece::getNom()</a>.</p>
<div class="dynheader">
Voici le graphe d'appel pour cette fonction :</div>
<div class="dyncontent">
<div class="center"><img src="class_t_p1_1_1_labyrinthe_ae14c211f4a87871e33a3477b0be1fd63_cgraph.png" border="0" usemap="#class_t_p1_1_1_labyrinthe_ae14c211f4a87871e33a3477b0be1fd63_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a854dc263c65a447286038fde7843ec41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854dc263c65a447286038fde7843ec41">&#9670;&nbsp;</a></span>chargeLabyrinthe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TP1::Labyrinthe::chargeLabyrinthe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_t_p1.html#a8b5ef3e0301394a6503b5b11ab59690e">Couleur</a>&#160;</td>
          <td class="paramname"><em>couleur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ifstream &amp;&#160;</td>
          <td class="paramname"><em>entree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Méthode fournie dans le fichier <a class="el" href="_labyrinthe_8cpp.html" title="Le code des méthodes membres et privés de la classe Labyrinthe.">Labyrinthe.cpp</a>, elle charge un fichier contenant un labyrinthe d'une certaine couleur. </p>
<p>Fonction déjà fournie permettant de charger un labyrinthe depuis un fichier.</p>
<p>Voici comment un labyrinthe est mis en mémoire: 1- ChargerLabyrinthe() appelle <a class="el" href="class_t_p1_1_1_labyrinthe.html#a720f66e4297666f346bb24a05cc5a973" title="Cette fonction doit ajouter la pièce p à un labyrinthe.">ajoutePieceLabyrinthe()</a> 2- <a class="el" href="class_t_p1_1_1_labyrinthe.html#a720f66e4297666f346bb24a05cc5a973" title="Cette fonction doit ajouter la pièce p à un labyrinthe.">ajoutePieceLabyrinthe()</a> ajoute la pièce si elle n'existe pas déjà. 3- Si la pièce existe déjà, <a class="el" href="class_t_p1_1_1_labyrinthe.html#a720f66e4297666f346bb24a05cc5a973" title="Cette fonction doit ajouter la pièce p à un labyrinthe.">ajoutePieceLabyrinthe()</a> n'ajoute pas de pièce et laisse le programme rouler 4- On sort de <a class="el" href="class_t_p1_1_1_labyrinthe.html#a720f66e4297666f346bb24a05cc5a973" title="Cette fonction doit ajouter la pièce p à un labyrinthe.">ajoutePieceLabyrinthe()</a> et ChargerLabyrinthe() fait quelques opérations pour ensuite appeler <a class="el" href="class_t_p1_1_1_labyrinthe.html#a4b4d2f9b7dc1c3572e720269b9bdad0b" title="Méthode privée fournie dans le fichier Labyrinthe.cpp, elle ajoute un passage dans un labyrinthe.">ajoutePassage()</a> 5- <a class="el" href="class_t_p1_1_1_labyrinthe.html#a4b4d2f9b7dc1c3572e720269b9bdad0b" title="Méthode privée fournie dans le fichier Labyrinthe.cpp, elle ajoute un passage dans un labyrinthe.">ajoutePassage()</a> ajoute les portes à la pièce qui à été préalablement créée ou qui existait déjà 6- La pièce et les portes sont créées et on passe à une autre pièce</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">couleur</td><td>La couleur du jouer auquel le labyrinthe chargé s'applique </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entree</td><td>Fichier contenant la définition du labyrinthe </td></tr>
  </table>
  </dd>
</dl>
<p>Une chaîne pour écrire dedans, cette chaîne servira pour nommer les pièces du labyrinthe</p>

<p class="reference">Référencé par <a class="el" href="_principal_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a7e2ef4938471d2739e877c7d131b8e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2ef4938471d2739e877c7d131b8e3e">&#9670;&nbsp;</a></span>getArrivee()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_p1_1_1_piece.html">Piece</a>* TP1::Labyrinthe::getArrivee </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesseur pour le membre arrivee. </p>

<p class="reference">Références <a class="el" href="class_t_p1_1_1_labyrinthe.html#a96b79d83a29c1790677c446439092545">arrivee</a>.</p>

</div>
</div>
<a id="ac9fc76e432836bbf89547e5489784520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9fc76e432836bbf89547e5489784520">&#9670;&nbsp;</a></span>getDepart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_p1_1_1_piece.html">Piece</a>* TP1::Labyrinthe::getDepart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesseur pour le membre depart. </p>

<p class="reference">Références <a class="el" href="class_t_p1_1_1_labyrinthe.html#a41c30a4b682aa2846674740f9ae011ee">depart</a>.</p>

</div>
</div>
<a id="a2a0f6278ee9ab2f47a48f7811f9ab095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0f6278ee9ab2f47a48f7811f9ab095">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_t_p1_1_1_labyrinthe.html">Labyrinthe</a>&amp; TP1::Labyrinthe::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_p1_1_1_labyrinthe.html">Labyrinthe</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Surcharge de l'opérateur =. </p>

</div>
</div>
<a id="adfe6b916bc3ab9ac20dd130220ff1d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe6b916bc3ab9ac20dd130220ff1d81">&#9670;&nbsp;</a></span>placeArrivee()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TP1::Labyrinthe::placeArrivee </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Même chose que pour la fonction placeDepart décrite plus haut, mais pour le pointeur arrivee d'un labyrinthe. </p>

</div>
</div>
<a id="ac75016674aca0669c9ef0b8c25c8a3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75016674aca0669c9ef0b8c25c8a3b7">&#9670;&nbsp;</a></span>placeDepart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TP1::Labyrinthe::placeDepart </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Méthode privée, elle sert pour charger un labyrinthe. </p>
<p>Ajuste le pointeur depart d'un labyrinthe pour qu'il contienne l'adresse de la pièce correspondant au nom spécifié par nom. Lancer une exception logic_error si aucune pièce du labyrinthe ne porte le nom nom. </p>

</div>
</div>
<a id="abb99d3daf4ea5f84f1d810a84e295579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb99d3daf4ea5f84f1d810a84e295579">&#9670;&nbsp;</a></span>printPieces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TP1::Labyrinthe::printPieces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf2181692e1946ce3c42242acb34bcbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2181692e1946ce3c42242acb34bcbe">&#9670;&nbsp;</a></span>solutionner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TP1::Labyrinthe::solutionner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_t_p1.html#a8b5ef3e0301394a6503b5b11ab59690e">Couleur</a>&#160;</td>
          <td class="paramname"><em>joueur</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cette méthode doit solutionner un labyrinthe pour le joueur spécifié par joueur. </p>
<p>Elle doit donc trouver en combien d'étapes au minimum le joueur spécifié peut solutionner le labyrinthe, en ne passant bien sûr que par les portes qui correspondent à sa couleur.</p>
<p>Si un labyrinthe ne peut pas être solutionné par le joueur, il faut retourner -1. Dans ce cas, nous ne considèrerons pas cela comme un appel anormal de la fonction. Vous devez utiliser l'algorithme suivant pour solutionner le labyrinthe, en utilisant une file "queue" de la STL:</p><ol type="1">
<li>Enfiler la pièce de départ en lui associant une distance du départ de zéro.</li>
<li>Faire<ol type="a">
<li>Défiler une pièce</li>
<li><p class="startli">Enfiler toutes les pièces qui sont accessibles à partir de cette pièce à l'aide d'une porte de la couleur du joueur, et qui n'ont pas été déjà parcourues, en leur associant la distance du départ de la pièce défilée plus un.</p>
<p class="startli">Remarquez qu'il faut faire une vérification double ici. Il faut d'abord chercher les portes dans la liste de portes de la pièce défilée, puis il faut ensuite aussi chercher les portes dans les listes de portes de toutes les pièces pour voir s'il y en aurait qui mènent à la pièce défilée. Ceci est nécessaire car les portes ne sont pas à sens unique, mais la méthode qui charge un labyrinthe fournie ne les ajoute qu'une seule fois dans le modèle d'implantation. Afin de savoir si une pièce a déjà été parcourue ou non, employez le champ booléen parcourue. N'enfilez que des pièces pour lesquelles ce champ a false comme valeur, puis au moment où vous l'enfilez, appliquez-lui la valeur true. Aussi, n'oubliez pas, avant de commencer l'algorithme, de mettre ce champ à false pour toutes les pièces du labyrinthe.</p>
</li>
</ol>
</li>
</ol>
<p>Tant qu'il reste des pièces dans la file et que la pièce d'arrivée n'a pas encore été atteinte (défilée). </p>
<p>Reset les pieces</p>
<p>explorer le labyrinthe</p>
<p>ajouter les pieces lier aux porte de cette piece</p>
<p>ajouter les pieces qui ont des portes menant a la piece defile</p>

<p class="reference">Références <a class="el" href="class_t_p1_1_1_labyrinthe_1_1_noeud_liste_pieces.html#a0dfcd04c1cbe96c96568cb4045b1ed4a">TP1::Labyrinthe::NoeudListePieces::piece</a>, et <a class="el" href="class_t_p1_1_1_piece.html#a98c3d80561cf8cef97a703c845939af9">TP1::Piece::setParcourue()</a>.</p>
<div class="dynheader">
Voici le graphe d'appel pour cette fonction :</div>
<div class="dyncontent">
<div class="center"><img src="class_t_p1_1_1_labyrinthe_aaf2181692e1946ce3c42242acb34bcbe_cgraph.png" border="0" usemap="#class_t_p1_1_1_labyrinthe_aaf2181692e1946ce3c42242acb34bcbe_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a0c496d235d32655572107f1ea18b8978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c496d235d32655572107f1ea18b8978">&#9670;&nbsp;</a></span>trouveGagnant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_t_p1.html#a8b5ef3e0301394a6503b5b11ab59690e">Couleur</a> TP1::Labyrinthe::trouveGagnant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cette méthode devra appeler quatre fois la méthode <a class="el" href="class_t_p1_1_1_labyrinthe.html#aaf2181692e1946ce3c42242acb34bcbe" title="Cette méthode doit solutionner un labyrinthe pour le joueur spécifié par joueur.">solutionner()</a>, une fois par couleur, pour déterminer quel est le joueur qui peut solutionner le labyrinthe en le moins de déplacements. </p>
<p>Si aucun joueur ne peut solutionner un labyrinthe, retournez Aucun. Dans le cas où deux joueurs ou plus peuvent arriver ex-equo, accordez la priorité au joueur rouge, puis au joueur vert, puis au bleu, puis au jaune. Par exemple, si le joueur rouge peut solutionner le labyrinthe en 12 coups, le joueur vert en 8 coups, le joueur bleu en 9 coups, puis le jaune en 8 coups aussi, c'est le vert qui gagne. </p>

</div>
</div>
<a id="a5551ff7dce5becc68b2e6508c9d6d5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5551ff7dce5becc68b2e6508c9d6d5fb">&#9670;&nbsp;</a></span>trouvePiece()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_p1_1_1_labyrinthe_1_1_noeud_liste_pieces.html">Labyrinthe::NoeudListePieces</a> * TP1::Labyrinthe::trouvePiece </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Méthode privée. </p>
<p>Retourne l'adresse du noeud de la liste de pièces contenue dans le labyrinthe qui correspond à la pièce portant le nom nom, la méthode doit lancer une exception invalid_argument si le nom de la pièce est vide. La méthode doit lancer également une exception logic_error si la pièce est introuvable. Remarquez qu'il faut retourner l'adresse du noeud et non l'adresse de la pièce. </p>

</div>
</div>
<h2 class="groupheader">Documentation des données membres</h2>
<a id="a96b79d83a29c1790677c446439092545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b79d83a29c1790677c446439092545">&#9670;&nbsp;</a></span>arrivee</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_p1_1_1_piece.html">Piece</a>* TP1::Labyrinthe::arrivee</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adresse de la pièce d'arrivée (et non du noeud qui la contient) </p>

<p class="reference">Référencé par <a class="el" href="class_t_p1_1_1_labyrinthe.html#a7e2ef4938471d2739e877c7d131b8e3e">getArrivee()</a>.</p>

</div>
</div>
<a id="a41c30a4b682aa2846674740f9ae011ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c30a4b682aa2846674740f9ae011ee">&#9670;&nbsp;</a></span>depart</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_p1_1_1_piece.html">Piece</a>* TP1::Labyrinthe::depart</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adresse de la pièce de départ (et non du noeud qui la contient) </p>

<p class="reference">Référencé par <a class="el" href="class_t_p1_1_1_labyrinthe.html#ac9fc76e432836bbf89547e5489784520">getDepart()</a>.</p>

</div>
</div>
<a id="a8eb7ef93bae46710cbbc6b07db3e9184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb7ef93bae46710cbbc6b07db3e9184">&#9670;&nbsp;</a></span>dernier</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_p1_1_1_labyrinthe_1_1_noeud_liste_pieces.html">NoeudListePieces</a>* TP1::Labyrinthe::dernier</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Le dernier noeud de la liste chaînée circulaire. Ce noeuds ne contient pas nécessairement les pièces de départ ou d'arrivée. </p>

</div>
</div>
<hr/>La documentation de cette classe a été générée à partir des fichiers suivants :<ul>
<li><a class="el" href="_labyrinthe_8h.html">Labyrinthe.h</a></li>
<li><a class="el" href="_labyrinthe_8cpp.html">Labyrinthe.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_t_p1.html">TP1</a></li><li class="navelem"><a class="el" href="class_t_p1_1_1_labyrinthe.html">Labyrinthe</a></li>
    <li class="footer">Généré le Samedi 22 Février 2020 21:27:01 pour Algorithmique de graphes par
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
